/*
 * agc_cli.c
 *
 *  Created on: Nov 30, 2008
 *      Author: MZ211D
 */
#include <string.h>
#include <stdio.h>
#include "agc_cli.h"
#include "agc_engine.h"

/* Some legacy vars for now */
int FullNameMode = 0;
int QuietMode = 0;

static char CduLog[] = "yaAGC.cdulog";

static Options_t Options;

static void ShowUsage(void)
{
	printf ("USAGE:\n"
"\tyaAGC --core=filename [OPTIONS]\n\n"
"The core filename is a binary image of the program,\n"
"constants, and so forth, that are supposed to be in\n"
"the AGC\'s core-rope memory.  Such a file can be\n"
"created from AGC assembly language using the yaYUL\n"
"assembler (if and when I write it) or from from an ASCII\n"
"represention of the binary image using the Oct2Bin\n"
"program.\n\n"
"OPTIONS:.\n"
"--port=n      Change the server port number (default=19697).\n"
"--debug-dsky  Rather than run the core program, go into DSKY-debug\n"
"              mode.  In this mode send pre-determined codes to\n"
"              the DSKY upon receiving DSKY keypresses.\n"
"--debug-deda  This mode runs the core program as usual, but also\n"
"              responds to messages from yaDEDA and generates fake\n"
"              messages to yaDEDA for testing purposes.\n"
"--cfg=file    The name of a configuration file.  Presently, the\n"
"              configuration files is used only for --debug-dsky\n"
"              mode.  It would typically be the same configuration\n"
"              file as used for yaDSKY.\n"
"--debug       Use the GDB/MI debug interface to enable regular\n"
"              gdb cli interaction as well as gdb-front-ends.\n"
"--symtab=file The name of the symbol table file generated by yaYUL.\n"
"              If supplied, various debugging commands can take a\n"
"              symbol name as its argument.\n"
"--resume=file Use indicated file (previously created from the --debug\n"
"              mode\'s COREDUMP command) to initialize erasable memory,\n"
"              i/o channels, and hidden CPU state variables.  In\n"
"              effect, this allows you to take a snapshot of the AGC\n"
"              program and to resume its execution from that point,\n"
"              rather than always starting the AGC program with power-\n"
"              up defaults. The power-up default is to reload erasable\n"
"              memory with its contents at the prior power-down (from\n"
"              the file LM.core or CM.core), but not to restore the \n"
"              other state variables mentioned.  If you want a\n"
"              completely clean system, erase LM.core or CM.core.\n"
"              Alternately, if you want the state of the system to\n"
"              be identical to the state at last power-down, use \n"
"              --resume=LM.core or --resume=CM.core.\n"
"--interlace=N By default, yaAGC tries to read the socket interface\n"
"              by which it communicates with yaDSKY and other\n"
"              components between each N CPU instruction.\n"
"              In theory, a value of N=1 provides the intention of \n"
"              obtaining maximum responsiveness, but on some slower\n"
"              computers, however, the overhead from these socket-\n"
"              interrogations actually slows the system down\n"
"              substantially.  The default value of N is intended\n"
"              to be a reasonable compromise that should work well\n"
"              on most computers.  With the --interlace option, you can\n"
"              fine-tune the system by setting the socket-checks\n"
"              to occur every N-th CPU instruction instead.\n"
"--dump-time=N By default, yaAGC saves the contents of erasable memory\n"
"              to disk (in the file LM.core or CM.core) every 10 seconds\n"
"              so that when yaAGC is next run it will (sort of)\n"
"              retained the contents of erasable memory.  You can change\n"
"              that interval to N seconds with this switch.\n"
"--cdu-log     Used only for debugging.  Causes a file called yaAGC.cdulog\n"
"              to be created, containing data related to the bandwidth-\n"
"              limiting of CDU inputs PCDU and MCDU.\n"
"Note that the core-rope image should be exactly 36 banks\n"
"(36x1024=36864 words, or 73728 bytes) in size.  Other sizes\n"
"may be accepted, but it is unclear what (if any) utility such\n"
"core-rope images would have.  (In particular, if the core-rope\n"
"is supposed to be for actual Luminary or Colossus software, then\n"
"the checksums of the missing memory banks would be incorrect, and\n"
"so the built-in self-test would fail.)\n"
"\n");
}

extern FILE *rfopen (const char *Filename, const char *mode);


/*
 * We don't do a lot of checking here.  Too bad!  Maybe one day ....
 * Even so, returns 0 on "success" and 1 on known error.
 */
int ParseCfg (char *Filename)
{
  char s[129] = { 0 };
  int KeyCode, Channel, Value, Result = 1;
  char Logic;
  FILE *fin;

  fin = rfopen (Filename, "r");
  if (fin)
  {
     Result = 0;

	  while (NULL != fgets (s, sizeof (s) - 1, fin))
	  {
	      char *ss;

	      /* Find newline or form feed and replace with string termination */
	      for (ss = s; *ss; ss++) if (*ss == '\n' || *ss == '\r') *ss = 0;

			/* Parse string */
	      if (4 == sscanf(s,"DEBUG %d %o %c %x",&KeyCode,&Channel,&Logic,&Value))
			{
				/* Ensure valid values are porvided */
		  		if (Channel < 0 || Channel > 255) continue;
		  		if (Logic != '=' && Logic != '&' &&
		  		    Logic != '|' && Logic != '^') continue;
		  		if (Value != (Value & 0x7FFF)) continue;
		  		if (KeyCode < 0 || KeyCode > 31) continue;
		  		if (NumDebugRules >= MAX_DEBUG_RULES) break;

		  		/* Set the Debug Rules */
		  		DebugRules[NumDebugRules].KeyCode = KeyCode;
		  		DebugRules[NumDebugRules].Channel = Channel;
		  		DebugRules[NumDebugRules].Logic = Logic;
		  		DebugRules[NumDebugRules].Value = Value;
		  		NumDebugRules++;
			}
	      else if (!strcmp (s, "LMSIM")) CmOrLm = 0;
	      else if (!strcmp (s, "CMSIM")) CmOrLm = 1;
	  }
	  fclose (fin);
  }
  return (Result);
}


static void InitializeOptions(void)
{
	  Options.core = (char*)0;
	  Options.resume = (char*)0;
	  Options.cdu_log = (char*)0;
	  Options.symtab = (char*)0;
	  Options.cfg = (char*)0;
	  Options.port  = 19697;
	  Options.dump_time = 10;
	  Options.debug_dsky = 0;
	  Options.debug_deda = 0;
	  Options.quiet = 0;
	  Options.fullname = 0;
	  Options.debug = 0;
	  Options.resumed = 0;
	  Options.interlace = 50;
}

static int ParseToken(char* token)
{
	int result = 0;
	int j;
	char* p;

	if (!strcmp (token, "--help") || !strcmp (token, "/?"))	result = 1;
	else if (!strncmp (token, "--core=", 7)) Options.core = strdup(&token[7]);
	else if (!strncmp (token, "--resume=", 9))Options.resume = strdup(&token[9]);
	else if (1 == sscanf (token, "--port=%d", &j)) Options.port = j;
	else if (1 == sscanf (token, "--dump-time=%d", &j)) Options.dump_time = j;
	else if (!strcmp (token, "--debug-dsky")) Options.debug_dsky = 1;
	else if (!strcmp (token, "--debug-deda")) Options.debug_deda = 1;
	else if (!strcmp (token, "--cdu-log")) Options.cdu_log = CduLog;
	else if (!strncmp (token, "--cfg=", 6)) Options.cfg = strdup(&token[6]);
	else if (!strcmp (token, "--fullname")) Options.fullname = 1;
	else if (!strcmp (token, "--quiet"))Options.quiet = 1;
	else if (!strcmp (token, "--debug")) Options.debug = 1;
	else if (!strncmp (token, "--symtab=", 9)) Options.symtab = strdup(&token[9]);
	else if (1 == sscanf (token,"--interlace=%d", &j)) Options.interlace = j;
	else result = 1;

	return (result);
}


Options_t* ParseCommandLineOptions(int argc, char *argv[])
{
	Options_t* result = (Options_t*)0;
	int i, j;

	InitializeOptions();

	/* Parse the command-line tokens */
	for (i = 1; i < argc; i++) if (ParseToken(argv[i])) break;

	/* If there is an issue with the provided command line interface
	 * display the usage message. Otherwise proceed with the automatic
	 * values based on the core-ropes image name.
	 */
	if (argc == 1 || i < argc || (!Options.core && !Options.debug_dsky))
	{
		/* Show the usage message */
		ShowUsage();
	}
	else
	{
		/* Options are properly Parsed */
		result = &Options;

		/* Must have .bin extension to find the symbol table based on the
		 * core basename with the bin extension.
		 */
		if (strstr(Options.core,".bin"))
		{
			int FullPathLength = strlen(Options.core);

			/* If Debugging without symtab set default symtab */
			if (Options.debug && !Options.symtab)
			{
				Options.symtab = (char*)calloc(1,FullPathLength + 4);
				strcpy(Options.symtab,Options.core);
				strcpy(Options.symtab + strlen(Options.core)-3,"symtab");
			}
		}

		/* If a configuration file is specified load its contents */
		if (Options.cfg)
		{
			if (ParseCfg (Options.cfg))
			{
			  result = (Options_t*)0;
			  printf("\n*** Unknown configurstion file. ***\n\n");
			}
		}
	}

	return (result);
}
